/**
 * @file sqp_pendulum_demo_op_en.cpp
 *
 * @brief Demonstration of PANOC/ALM-based optimization for a pendulum system
 * using cost matrices generated from Python.
 *
 * This program demonstrates the use of PANOC (Proximal Averaged Newton-type
 * method for Optimal Control) with ALM (Augmented Lagrangian Method) for
 * solving an optimal control problem for a pendulum system. The cost matrices
 * are generated by running a Python script ("sqp_pendulum_demo_op_en.py"),
 * which outputs C++ code for the cost matrices.
 *
 * Key components:
 * - Loads cost matrices and types from generated C++ code.
 * - Defines cost function, gradient, output mapping, and output Jacobian
 * transpose functions for the ALM/PANOC solver.
 * - Initializes state and input horizon variables.
 * - Configures and runs the ALM/PM solver to optimize the control input
 * horizon.
 * - Outputs the optimized input horizon to the console.
 *
 * Dependencies:
 * - python_numpy.hpp: Provides Python-Numpy interoperability.
 * - python_optimization.hpp: Provides optimization utilities and solver
 * definitions.
 * - sqp_pendulum_demo_op_en_oe_cost_matrices.hpp: Contains cost matrices and
 * type definitions generated from Python.
 *
 * Usage:
 * 1. Run "sqp_pendulum_demo_op_en.py" to generate the required cost matrices
 * C++ code.
 * 2. Compile and run this program to perform the optimization and display
 * results.
 */
#include <iostream>

#include "python_numpy.hpp"
#include "python_optimization.hpp"

#include "sqp_pendulum_demo_op_en_oe_cost_matrices.hpp"

using namespace PythonNumpy;
using namespace PythonOptimization;

int main(void) {

  // First, you must run "sqp_pendulum_demo_op_en.py" to generate the cost
  // matrices C++ code.
  auto cost_matrices = sqp_pendulum_demo_op_en_oe_cost_matrices::make();

  using X_Type = sqp_pendulum_demo_op_en_oe_cost_matrices::X_Type;

  constexpr std::size_t STATE_SIZE =
      sqp_pendulum_demo_op_en_oe_cost_matrices::STATE_SIZE;
  constexpr std::size_t INPUT_SIZE =
      sqp_pendulum_demo_op_en_oe_cost_matrices::INPUT_SIZE;
  constexpr std::size_t OUTPUT_SIZE =
      sqp_pendulum_demo_op_en_oe_cost_matrices::OUTPUT_SIZE;
  constexpr std::size_t NP = sqp_pendulum_demo_op_en_oe_cost_matrices::NP;

  using Reference_Trajectory_Type =
      sqp_pendulum_demo_op_en_oe_cost_matrices::Reference_Trajectory_Type;

  using Cost_Matrices_Type = sqp_pendulum_demo_op_en_oe_cost_matrices::type;

  using U_Horizon_Type = DenseMatrix_Type<double, INPUT_SIZE, NP>;
  using Y_Horizon_Type = typename Cost_Matrices_Type::Y_Horizon_Type;

  /* ALM dimensions */
  constexpr std::size_t N1 = OUTPUT_SIZE * (NP + 1);
  constexpr std::size_t N2 = 0;

  using F1_Output_Type = DenseMatrix_Type<double, N1, 1>;
  using Xi_Type = DenseMatrix_Type<double, (1 + N1), 1>;

  /* Initial variables */
  Reference_Trajectory_Type reference_trajectory;

  auto X_initial = make_DenseMatrix<STATE_SIZE, 1>(
      static_cast<double>(3.141592653589793 / 4.0), static_cast<double>(0));

  cost_matrices.reference_trajectory = reference_trajectory;
  cost_matrices.X_initial = X_initial;

  U_Horizon_Type U_horizon_initial;

  /* Define ALM Factory */
  ALM_Factory_Type<Cost_Matrices_Type, N1, N2> alm_factory;

  alm_factory.set_cost_function(
      [&cost_matrices](const U_Horizon_Type &u) -> double {
        return cost_matrices.compute_cost(u);
      });

  alm_factory.set_gradient_function(
      [&cost_matrices](const U_Horizon_Type &u) -> U_Horizon_Type {
        return cost_matrices.compute_gradient(u);
      });

  auto mapping_f1_func =
      [&cost_matrices](const U_Horizon_Type &u) -> F1_Output_Type {
    auto Y_horizon = cost_matrices.compute_output_mapping(u);
    F1_Output_Type f1;
    for (std::size_t k = 0; k < (NP + 1); k++) {
      auto y_k = MatrixOperation::get_row(Y_horizon, k);
      for (std::size_t j = 0; j < OUTPUT_SIZE; j++) {
        f1(0, k * OUTPUT_SIZE + j) = y_k(0, j);
      }
    }
    return f1;
  };

  alm_factory.set_mapping_f1(mapping_f1_func);

  alm_factory.set_jacobian_f1_trans(
      [&cost_matrices](const U_Horizon_Type &u,
                       const F1_Output_Type &d) -> U_Horizon_Type {
        using Y_Type = sqp_pendulum_demo_op_en_oe_cost_matrices::Y_Type;
        Y_Horizon_Type D;
        for (std::size_t k = 0; k < (NP + 1); k++) {
          Y_Type d_k;
          for (std::size_t j = 0; j < OUTPUT_SIZE; j++) {
            d_k(0, j) = d(0, k * OUTPUT_SIZE + j);
          }
          MatrixOperation::set_row(D, d_k, k);
        }
        return cost_matrices.compute_output_jacobian_trans(u, D);
      });

  /* Output constraint Box Projection (unconstrained: -inf to +inf) */
  F1_Output_Type y_min_flat, y_max_flat;
  for (std::size_t k = 0; k < (NP + 1); k++) {
    for (std::size_t j = 0; j < OUTPUT_SIZE; j++) {
      y_min_flat(0, k * OUTPUT_SIZE + j) = static_cast<double>(-1e10);
      y_max_flat(0, k * OUTPUT_SIZE + j) = static_cast<double>(1e10);
    }
  }

  BoxProjectionOperator_Type<double, N1> box_proj_c(y_min_flat, y_max_flat);

  alm_factory.set_c_projection(
      [&box_proj_c](F1_Output_Type &x) { box_proj_c.project(x); });

  /* Define ALM Problem */
  ALM_Problem_Type<Cost_Matrices_Type, N1, N2> problem;

  problem.set_parametric_cost(
      [&alm_factory](const U_Horizon_Type &u, const Xi_Type &xi) -> double {
        return alm_factory.psi(u, xi);
      });

  problem.set_parametric_gradient(
      [&alm_factory](const U_Horizon_Type &u,
                     const Xi_Type &xi) -> U_Horizon_Type {
        return alm_factory.d_psi(u, xi);
      });

  problem.set_u_min_matrix(cost_matrices.get_U_min_matrix());
  problem.set_u_max_matrix(cost_matrices.get_U_max_matrix());
  problem.set_mapping_f1(mapping_f1_func);

  problem.set_c_projection(
      [&box_proj_c](F1_Output_Type &x) { box_proj_c.project(x); });

  /* ALM/PM Optimizer */
  auto solver = make_ALM_PM_Optimizer<Cost_Matrices_Type, N1, N2>();

  solver.set_problem(problem);

  /* solve */
  solver.set_solver_max_iteration(30, 500);

  auto U_horizon_opt = solver.solve(U_horizon_initial);

  auto status = solver.get_solver_status();

  std::cout << "Optimized cost: " << status.cost << std::endl;

  std::cout << "U_horizon_opt = \n" << std::endl;

  for (std::size_t i = 0; i < INPUT_SIZE; i++) {
    for (std::size_t j = 0; j < NP; j++) {
      std::cout << U_horizon_opt(i, j) << ", ";
    }
    std::cout << std::endl;
  }
  std::cout << std::endl;

  return 0;
}
